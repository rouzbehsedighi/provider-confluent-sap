// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DomainRulesInitParameters struct {

	// The boolean flag to control whether the rule should be disabled. Defaults to false.
	// Defaults to `false`.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// An optional description of the rule. Defaults to "".
	// Defaults to “.
	Doc *string `json:"doc,omitempty" tf:"doc,omitempty"`

	// The rule body. Data quality and transformation rules use CEL language expressions, data migration rules use JSONata expressions. Defaults to "".
	// Defaults to “.
	Expr *string `json:"expr,omitempty" tf:"expr,omitempty"`

	// The kind of the rule. Accepted values are CONDITION and TRANSFORM. CONDITION - validate the value of a field, TRANSFORM - transform the value of a field. Data quality rules use CONDITION kind, data transformation, encryption and migration rules use TRANSFORM kind.
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The mode of the rule. Accepted values are UPGRADE, DOWNGRADE, UPDOWN, WRITE, READ, and WRITEREAD.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// The name of the subject, representing the subject under which the referenced schema is registered.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// An optional action to execute if the rule fails, otherwise the built-in action type ERROR is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, as mentioned above. Defaults to ERROR,ERROR.
	// Defaults to `ERROR,ERROR`.
	OnFailure *string `json:"onFailure,omitempty" tf:"on_failure,omitempty"`

	// An optional action to execute if the rule succeeds, otherwise the built-in action type NONE is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, such as NONE,ERROR for a WRITEREAD rule. In this case NONE applies to WRITE and ERROR applies to READ. Defaults to NONE,NONE.
	// Defaults to `NONE,NONE`.
	OnSuccess *string `json:"onSuccess,omitempty" tf:"on_success,omitempty"`

	// A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
	Params map[string]*string `json:"params,omitempty" tf:"params,omitempty"`

	// supports the following:
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (CEL) is used for data quality and transformation rules, Confluent ENCRYPT is used for data encryption rules, and JSONata is used for migration rules.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type DomainRulesObservation struct {

	// The boolean flag to control whether the rule should be disabled. Defaults to false.
	// Defaults to `false`.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// An optional description of the rule. Defaults to "".
	// Defaults to “.
	Doc *string `json:"doc,omitempty" tf:"doc,omitempty"`

	// The rule body. Data quality and transformation rules use CEL language expressions, data migration rules use JSONata expressions. Defaults to "".
	// Defaults to “.
	Expr *string `json:"expr,omitempty" tf:"expr,omitempty"`

	// The kind of the rule. Accepted values are CONDITION and TRANSFORM. CONDITION - validate the value of a field, TRANSFORM - transform the value of a field. Data quality rules use CONDITION kind, data transformation, encryption and migration rules use TRANSFORM kind.
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The mode of the rule. Accepted values are UPGRADE, DOWNGRADE, UPDOWN, WRITE, READ, and WRITEREAD.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// The name of the subject, representing the subject under which the referenced schema is registered.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// An optional action to execute if the rule fails, otherwise the built-in action type ERROR is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, as mentioned above. Defaults to ERROR,ERROR.
	// Defaults to `ERROR,ERROR`.
	OnFailure *string `json:"onFailure,omitempty" tf:"on_failure,omitempty"`

	// An optional action to execute if the rule succeeds, otherwise the built-in action type NONE is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, such as NONE,ERROR for a WRITEREAD rule. In this case NONE applies to WRITE and ERROR applies to READ. Defaults to NONE,NONE.
	// Defaults to `NONE,NONE`.
	OnSuccess *string `json:"onSuccess,omitempty" tf:"on_success,omitempty"`

	// A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
	Params map[string]*string `json:"params,omitempty" tf:"params,omitempty"`

	// supports the following:
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (CEL) is used for data quality and transformation rules, Confluent ENCRYPT is used for data encryption rules, and JSONata is used for migration rules.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type DomainRulesParameters struct {

	// The boolean flag to control whether the rule should be disabled. Defaults to false.
	// Defaults to `false`.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// An optional description of the rule. Defaults to "".
	// Defaults to “.
	// +kubebuilder:validation:Optional
	Doc *string `json:"doc,omitempty" tf:"doc,omitempty"`

	// The rule body. Data quality and transformation rules use CEL language expressions, data migration rules use JSONata expressions. Defaults to "".
	// Defaults to “.
	// +kubebuilder:validation:Optional
	Expr *string `json:"expr,omitempty" tf:"expr,omitempty"`

	// The kind of the rule. Accepted values are CONDITION and TRANSFORM. CONDITION - validate the value of a field, TRANSFORM - transform the value of a field. Data quality rules use CONDITION kind, data transformation, encryption and migration rules use TRANSFORM kind.
	// +kubebuilder:validation:Optional
	Kind *string `json:"kind" tf:"kind,omitempty"`

	// The mode of the rule. Accepted values are UPGRADE, DOWNGRADE, UPDOWN, WRITE, READ, and WRITEREAD.
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// The name of the subject, representing the subject under which the referenced schema is registered.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// An optional action to execute if the rule fails, otherwise the built-in action type ERROR is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, as mentioned above. Defaults to ERROR,ERROR.
	// Defaults to `ERROR,ERROR`.
	// +kubebuilder:validation:Optional
	OnFailure *string `json:"onFailure,omitempty" tf:"on_failure,omitempty"`

	// An optional action to execute if the rule succeeds, otherwise the built-in action type NONE is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, such as NONE,ERROR for a WRITEREAD rule. In this case NONE applies to WRITE and ERROR applies to READ. Defaults to NONE,NONE.
	// Defaults to `NONE,NONE`.
	// +kubebuilder:validation:Optional
	OnSuccess *string `json:"onSuccess,omitempty" tf:"on_success,omitempty"`

	// A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
	// +kubebuilder:validation:Optional
	Params map[string]*string `json:"params,omitempty" tf:"params,omitempty"`

	// supports the following:
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (CEL) is used for data quality and transformation rules, Confluent ENCRYPT is used for data encryption rules, and JSONata is used for migration rules.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type MetadataInitParameters struct {

	// The custom properties to set:
	Properties map[string]*string `json:"properties,omitempty" tf:"properties,omitempty"`

	// A list of metadata properties to be encrypted.
	Sensitive []*string `json:"sensitive,omitempty" tf:"sensitive,omitempty"`

	// supports the following:
	Tags []TagsInitParameters `json:"tags,omitempty" tf:"tags,omitempty"`
}

type MetadataObservation struct {

	// The custom properties to set:
	Properties map[string]*string `json:"properties,omitempty" tf:"properties,omitempty"`

	// A list of metadata properties to be encrypted.
	Sensitive []*string `json:"sensitive,omitempty" tf:"sensitive,omitempty"`

	// supports the following:
	Tags []TagsObservation `json:"tags,omitempty" tf:"tags,omitempty"`
}

type MetadataParameters struct {

	// The custom properties to set:
	// +kubebuilder:validation:Optional
	Properties map[string]*string `json:"properties,omitempty" tf:"properties,omitempty"`

	// A list of metadata properties to be encrypted.
	// +kubebuilder:validation:Optional
	Sensitive []*string `json:"sensitive,omitempty" tf:"sensitive,omitempty"`

	// supports the following:
	// +kubebuilder:validation:Optional
	Tags []TagsParameters `json:"tags,omitempty" tf:"tags,omitempty"`
}

type MigrationRulesInitParameters struct {

	// The boolean flag to control whether the rule should be disabled. Defaults to false.
	// Defaults to `false`.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// An optional description of the rule. Defaults to "".
	// Defaults to “.
	Doc *string `json:"doc,omitempty" tf:"doc,omitempty"`

	// The rule body. Data quality and transformation rules use CEL language expressions, data migration rules use JSONata expressions. Defaults to "".
	// Defaults to “.
	Expr *string `json:"expr,omitempty" tf:"expr,omitempty"`

	// The kind of the rule. Accepted values are CONDITION and TRANSFORM. CONDITION - validate the value of a field, TRANSFORM - transform the value of a field. Data quality rules use CONDITION kind, data transformation, encryption and migration rules use TRANSFORM kind.
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The mode of the rule. Accepted values are UPGRADE, DOWNGRADE, UPDOWN, WRITE, READ, and WRITEREAD.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// The name of the subject, representing the subject under which the referenced schema is registered.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// An optional action to execute if the rule fails, otherwise the built-in action type ERROR is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, as mentioned above. Defaults to ERROR,ERROR.
	// Defaults to `ERROR,ERROR`.
	OnFailure *string `json:"onFailure,omitempty" tf:"on_failure,omitempty"`

	// An optional action to execute if the rule succeeds, otherwise the built-in action type NONE is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, such as NONE,ERROR for a WRITEREAD rule. In this case NONE applies to WRITE and ERROR applies to READ. Defaults to NONE,NONE.
	// Defaults to `NONE,NONE`.
	OnSuccess *string `json:"onSuccess,omitempty" tf:"on_success,omitempty"`

	// A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
	Params map[string]*string `json:"params,omitempty" tf:"params,omitempty"`

	// supports the following:
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (CEL) is used for data quality and transformation rules, Confluent ENCRYPT is used for data encryption rules, and JSONata is used for migration rules.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type MigrationRulesObservation struct {

	// The boolean flag to control whether the rule should be disabled. Defaults to false.
	// Defaults to `false`.
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// An optional description of the rule. Defaults to "".
	// Defaults to “.
	Doc *string `json:"doc,omitempty" tf:"doc,omitempty"`

	// The rule body. Data quality and transformation rules use CEL language expressions, data migration rules use JSONata expressions. Defaults to "".
	// Defaults to “.
	Expr *string `json:"expr,omitempty" tf:"expr,omitempty"`

	// The kind of the rule. Accepted values are CONDITION and TRANSFORM. CONDITION - validate the value of a field, TRANSFORM - transform the value of a field. Data quality rules use CONDITION kind, data transformation, encryption and migration rules use TRANSFORM kind.
	Kind *string `json:"kind,omitempty" tf:"kind,omitempty"`

	// The mode of the rule. Accepted values are UPGRADE, DOWNGRADE, UPDOWN, WRITE, READ, and WRITEREAD.
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// The name of the subject, representing the subject under which the referenced schema is registered.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// An optional action to execute if the rule fails, otherwise the built-in action type ERROR is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, as mentioned above. Defaults to ERROR,ERROR.
	// Defaults to `ERROR,ERROR`.
	OnFailure *string `json:"onFailure,omitempty" tf:"on_failure,omitempty"`

	// An optional action to execute if the rule succeeds, otherwise the built-in action type NONE is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, such as NONE,ERROR for a WRITEREAD rule. In this case NONE applies to WRITE and ERROR applies to READ. Defaults to NONE,NONE.
	// Defaults to `NONE,NONE`.
	OnSuccess *string `json:"onSuccess,omitempty" tf:"on_success,omitempty"`

	// A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
	Params map[string]*string `json:"params,omitempty" tf:"params,omitempty"`

	// supports the following:
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (CEL) is used for data quality and transformation rules, Confluent ENCRYPT is used for data encryption rules, and JSONata is used for migration rules.
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type MigrationRulesParameters struct {

	// The boolean flag to control whether the rule should be disabled. Defaults to false.
	// Defaults to `false`.
	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// An optional description of the rule. Defaults to "".
	// Defaults to “.
	// +kubebuilder:validation:Optional
	Doc *string `json:"doc,omitempty" tf:"doc,omitempty"`

	// The rule body. Data quality and transformation rules use CEL language expressions, data migration rules use JSONata expressions. Defaults to "".
	// Defaults to “.
	// +kubebuilder:validation:Optional
	Expr *string `json:"expr,omitempty" tf:"expr,omitempty"`

	// The kind of the rule. Accepted values are CONDITION and TRANSFORM. CONDITION - validate the value of a field, TRANSFORM - transform the value of a field. Data quality rules use CONDITION kind, data transformation, encryption and migration rules use TRANSFORM kind.
	// +kubebuilder:validation:Optional
	Kind *string `json:"kind" tf:"kind,omitempty"`

	// The mode of the rule. Accepted values are UPGRADE, DOWNGRADE, UPDOWN, WRITE, READ, and WRITEREAD.
	// +kubebuilder:validation:Optional
	Mode *string `json:"mode" tf:"mode,omitempty"`

	// The name of the subject, representing the subject under which the referenced schema is registered.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// An optional action to execute if the rule fails, otherwise the built-in action type ERROR is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, as mentioned above. Defaults to ERROR,ERROR.
	// Defaults to `ERROR,ERROR`.
	// +kubebuilder:validation:Optional
	OnFailure *string `json:"onFailure,omitempty" tf:"on_failure,omitempty"`

	// An optional action to execute if the rule succeeds, otherwise the built-in action type NONE is used. For UPDOWN and WRITEREAD rules, one can specify two actions separated by commas, such as NONE,ERROR for a WRITEREAD rule. In this case NONE applies to WRITE and ERROR applies to READ. Defaults to NONE,NONE.
	// Defaults to `NONE,NONE`.
	// +kubebuilder:validation:Optional
	OnSuccess *string `json:"onSuccess,omitempty" tf:"on_success,omitempty"`

	// A set of static parameters for the rule, which is optional. These are key-value pairs that are passed to the rule.
	// +kubebuilder:validation:Optional
	Params map[string]*string `json:"params,omitempty" tf:"params,omitempty"`

	// supports the following:
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The type of rule, which invokes a specific rule executor that that will run the rule. Google Common Expression Language (CEL) is used for data quality and transformation rules, Confluent ENCRYPT is used for data encryption rules, and JSONata is used for migration rules.
	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type RulesetInitParameters struct {

	// supports the following:
	DomainRules []DomainRulesInitParameters `json:"domainRules,omitempty" tf:"domain_rules,omitempty"`

	// supports the following:
	MigrationRules []MigrationRulesInitParameters `json:"migrationRules,omitempty" tf:"migration_rules,omitempty"`
}

type RulesetObservation struct {

	// supports the following:
	DomainRules []DomainRulesObservation `json:"domainRules,omitempty" tf:"domain_rules,omitempty"`

	// supports the following:
	MigrationRules []MigrationRulesObservation `json:"migrationRules,omitempty" tf:"migration_rules,omitempty"`
}

type RulesetParameters struct {

	// supports the following:
	// +kubebuilder:validation:Optional
	DomainRules []DomainRulesParameters `json:"domainRules,omitempty" tf:"domain_rules,omitempty"`

	// supports the following:
	// +kubebuilder:validation:Optional
	MigrationRules []MigrationRulesParameters `json:"migrationRules,omitempty" tf:"migration_rules,omitempty"`
}

type SchemaCredentialsInitParameters struct {
}

type SchemaCredentialsObservation struct {
}

type SchemaCredentialsParameters struct {

	// The Schema Registry API Key.
	// The Cluster API Key for your Confluent Cloud cluster.
	// +kubebuilder:validation:Required
	KeySecretRef v1.SecretKeySelector `json:"keySecretRef" tf:"-"`

	// The Schema Registry API Secret.
	// The Cluster API Secret for your Confluent Cloud cluster.
	// +kubebuilder:validation:Required
	SecretSecretRef v1.SecretKeySelector `json:"secretSecretRef" tf:"-"`
}

type SchemaInitParameters struct {

	// supports the following:
	// The Cluster API Credentials.
	Credentials []SchemaCredentialsInitParameters `json:"credentials,omitempty" tf:"credentials,omitempty"`

	// The format of the schema. Accepted values are: AVRO, PROTOBUF, and JSON.
	// The format of the Schema.
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// An optional flag to control whether a schema should be soft or hard deleted. Set it to true if you want to hard delete a schema on destroy (see Schema Deletion Guidelines for more details). Must be unset when importing. Defaults to false (soft delete).
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete). Defaults to `false`.
	HardDelete *bool `json:"hardDelete,omitempty" tf:"hard_delete,omitempty"`

	// See here for more details. Supports the following:
	Metadata []MetadataInitParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// An optional flag to control whether a schema should be recreated on an update. Set it to true if you want to manage different schema versions using different resource instances. Must be set to the target value when importing. Defaults to false, which manages the latest schema version only. The resource instance always points to the latest schema version by supporting in-place updates.
	// Controls whether a schema should be recreated on update. Defaults to `false`.
	RecreateOnUpdate *bool `json:"recreateOnUpdate,omitempty" tf:"recreate_on_update,omitempty"`

	// The REST endpoint of the Schema Registry cluster. For example, for public networking: https://psrc-00000.us-central1.gcp.confluent.cloud. In the case of private networking, the endpoint might look like https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud. You can construct it using either:
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint *string `json:"restEndpoint,omitempty" tf:"rest_endpoint,omitempty"`

	// The list of schema rules. See Data Contracts for Schema Registry for more details. For example, these rules can enforce that a field that contains sensitive information must be encrypted, or that a message containing an invalid age must be sent to a dead letter queue.
	Ruleset []RulesetInitParameters `json:"ruleset,omitempty" tf:"ruleset,omitempty"`

	// The schema string, for example, file("./schema_version_1.avsc").
	// The definition of the Schema.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The list of referenced schemas (see Schema References for more details):
	// The list of references to other Schemas.
	SchemaReference []SchemaReferenceInitParameters `json:"schemaReference,omitempty" tf:"schema_reference,omitempty"`

	// supports the following:
	SchemaRegistryCluster []SchemaRegistryClusterInitParameters `json:"schemaRegistryCluster,omitempty" tf:"schema_registry_cluster,omitempty"`

	// Defaults to false. Defaults to `false`.
	SkipValidationDuringPlan *bool `json:"skipValidationDuringPlan,omitempty" tf:"skip_validation_during_plan,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the Schema Registry Subject.
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`
}

type SchemaObservation struct {

	// supports the following:
	// The Cluster API Credentials.
	Credentials []SchemaCredentialsParameters `json:"credentials,omitempty" tf:"credentials,omitempty"`

	// The format of the schema. Accepted values are: AVRO, PROTOBUF, and JSON.
	// The format of the Schema.
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// An optional flag to control whether a schema should be soft or hard deleted. Set it to true if you want to hard delete a schema on destroy (see Schema Deletion Guidelines for more details). Must be unset when importing. Defaults to false (soft delete).
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete). Defaults to `false`.
	HardDelete *bool `json:"hardDelete,omitempty" tf:"hard_delete,omitempty"`

	// The ID of the Schema Registry cluster, for example, lsrc-abc123.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// See here for more details. Supports the following:
	Metadata []MetadataObservation `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// An optional flag to control whether a schema should be recreated on an update. Set it to true if you want to manage different schema versions using different resource instances. Must be set to the target value when importing. Defaults to false, which manages the latest schema version only. The resource instance always points to the latest schema version by supporting in-place updates.
	// Controls whether a schema should be recreated on update. Defaults to `false`.
	RecreateOnUpdate *bool `json:"recreateOnUpdate,omitempty" tf:"recreate_on_update,omitempty"`

	// The REST endpoint of the Schema Registry cluster. For example, for public networking: https://psrc-00000.us-central1.gcp.confluent.cloud. In the case of private networking, the endpoint might look like https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud. You can construct it using either:
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	RestEndpoint *string `json:"restEndpoint,omitempty" tf:"rest_endpoint,omitempty"`

	// The list of schema rules. See Data Contracts for Schema Registry for more details. For example, these rules can enforce that a field that contains sensitive information must be encrypted, or that a message containing an invalid age must be sent to a dead letter queue.
	Ruleset []RulesetObservation `json:"ruleset,omitempty" tf:"ruleset,omitempty"`

	// The schema string, for example, file("./schema_version_1.avsc").
	// The definition of the Schema.
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The globally unique ID of the Schema, for example, 100003. If the same schema is registered under a different subject, the same identifier will be returned. However, the version of the schema may be different under different subjects.
	// Globally unique identifier of the Schema returned for a creation request. It should be used to retrieve this schema from the schemas resource and is different from the schema’s version which is associated with the subject.
	SchemaIdentifier *float64 `json:"schemaIdentifier,omitempty" tf:"schema_identifier,omitempty"`

	// The list of referenced schemas (see Schema References for more details):
	// The list of references to other Schemas.
	SchemaReference []SchemaReferenceObservation `json:"schemaReference,omitempty" tf:"schema_reference,omitempty"`

	// supports the following:
	SchemaRegistryCluster []SchemaRegistryClusterObservation `json:"schemaRegistryCluster,omitempty" tf:"schema_registry_cluster,omitempty"`

	// Defaults to false. Defaults to `false`.
	SkipValidationDuringPlan *bool `json:"skipValidationDuringPlan,omitempty" tf:"skip_validation_during_plan,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the Schema Registry Subject.
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`

	// The version, representing the exact version of the schema under the registered subject.
	// The version number of the Schema.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SchemaParameters struct {

	// supports the following:
	// The Cluster API Credentials.
	// +kubebuilder:validation:Optional
	Credentials []SchemaCredentialsParameters `json:"credentials,omitempty" tf:"credentials,omitempty"`

	// The format of the schema. Accepted values are: AVRO, PROTOBUF, and JSON.
	// The format of the Schema.
	// +kubebuilder:validation:Optional
	Format *string `json:"format,omitempty" tf:"format,omitempty"`

	// An optional flag to control whether a schema should be soft or hard deleted. Set it to true if you want to hard delete a schema on destroy (see Schema Deletion Guidelines for more details). Must be unset when importing. Defaults to false (soft delete).
	// Controls whether a schema should be soft or hard deleted. Set it to `true` if you want to hard delete a schema on destroy. Defaults to `false` (soft delete). Defaults to `false`.
	// +kubebuilder:validation:Optional
	HardDelete *bool `json:"hardDelete,omitempty" tf:"hard_delete,omitempty"`

	// See here for more details. Supports the following:
	// +kubebuilder:validation:Optional
	Metadata []MetadataParameters `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// An optional flag to control whether a schema should be recreated on an update. Set it to true if you want to manage different schema versions using different resource instances. Must be set to the target value when importing. Defaults to false, which manages the latest schema version only. The resource instance always points to the latest schema version by supporting in-place updates.
	// Controls whether a schema should be recreated on update. Defaults to `false`.
	// +kubebuilder:validation:Optional
	RecreateOnUpdate *bool `json:"recreateOnUpdate,omitempty" tf:"recreate_on_update,omitempty"`

	// The REST endpoint of the Schema Registry cluster. For example, for public networking: https://psrc-00000.us-central1.gcp.confluent.cloud. In the case of private networking, the endpoint might look like https://lsrc-abc123.pr1jy6.us-east-2.aws.confluent.cloud. You can construct it using either:
	// The REST endpoint of the Schema Registry cluster, for example, `https://psrc-00000.us-central1.gcp.confluent.cloud:443`).
	// +kubebuilder:validation:Optional
	RestEndpoint *string `json:"restEndpoint,omitempty" tf:"rest_endpoint,omitempty"`

	// The list of schema rules. See Data Contracts for Schema Registry for more details. For example, these rules can enforce that a field that contains sensitive information must be encrypted, or that a message containing an invalid age must be sent to a dead letter queue.
	// +kubebuilder:validation:Optional
	Ruleset []RulesetParameters `json:"ruleset,omitempty" tf:"ruleset,omitempty"`

	// The schema string, for example, file("./schema_version_1.avsc").
	// The definition of the Schema.
	// +kubebuilder:validation:Optional
	Schema *string `json:"schema,omitempty" tf:"schema,omitempty"`

	// The list of referenced schemas (see Schema References for more details):
	// The list of references to other Schemas.
	// +kubebuilder:validation:Optional
	SchemaReference []SchemaReferenceParameters `json:"schemaReference,omitempty" tf:"schema_reference,omitempty"`

	// supports the following:
	// +kubebuilder:validation:Optional
	SchemaRegistryCluster []SchemaRegistryClusterParameters `json:"schemaRegistryCluster,omitempty" tf:"schema_registry_cluster,omitempty"`

	// Defaults to false. Defaults to `false`.
	// +kubebuilder:validation:Optional
	SkipValidationDuringPlan *bool `json:"skipValidationDuringPlan,omitempty" tf:"skip_validation_during_plan,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the Schema Registry Subject.
	// +kubebuilder:validation:Optional
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`
}

type SchemaReferenceInitParameters struct {

	// The name of the subject, representing the subject under which the referenced schema is registered.
	// The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the referenced Schema Registry Subject (for example, "User").
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`

	// The version, representing the exact version of the schema under the registered subject.
	// The version of the referenced Schema.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SchemaReferenceObservation struct {

	// The name of the subject, representing the subject under which the referenced schema is registered.
	// The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the referenced Schema Registry Subject (for example, "User").
	SubjectName *string `json:"subjectName,omitempty" tf:"subject_name,omitempty"`

	// The version, representing the exact version of the schema under the registered subject.
	// The version of the referenced Schema.
	Version *float64 `json:"version,omitempty" tf:"version,omitempty"`
}

type SchemaReferenceParameters struct {

	// The name of the subject, representing the subject under which the referenced schema is registered.
	// The name of the Schema references (for example, "io.confluent.kafka.example.User"). For Avro, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf, it is the name of another Protobuf file.
	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// The name for the reference. (For Avro Schema, the reference name is the fully qualified schema name, for JSON Schema it is a URL, and for Protobuf Schema, it is the name of another Protobuf file.)
	// The name of the referenced Schema Registry Subject (for example, "User").
	// +kubebuilder:validation:Optional
	SubjectName *string `json:"subjectName" tf:"subject_name,omitempty"`

	// The version, representing the exact version of the schema under the registered subject.
	// The version of the referenced Schema.
	// +kubebuilder:validation:Optional
	Version *float64 `json:"version" tf:"version,omitempty"`
}

type SchemaRegistryClusterInitParameters struct {

	// The ID of the Schema Registry cluster, for example, lsrc-abc123.
	// The Schema Registry cluster ID (e.g., `lsrc-abc123`).
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SchemaRegistryClusterObservation struct {

	// The ID of the Schema Registry cluster, for example, lsrc-abc123.
	// The Schema Registry cluster ID (e.g., `lsrc-abc123`).
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type SchemaRegistryClusterParameters struct {

	// The ID of the Schema Registry cluster, for example, lsrc-abc123.
	// The Schema Registry cluster ID (e.g., `lsrc-abc123`).
	// +kubebuilder:validation:Optional
	ID *string `json:"id" tf:"id,omitempty"`
}

type TagsInitParameters struct {

	// The Schema Registry API Key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The setting value.
	Value []*string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagsObservation struct {

	// The Schema Registry API Key.
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The setting value.
	Value []*string `json:"value,omitempty" tf:"value,omitempty"`
}

type TagsParameters struct {

	// The Schema Registry API Key.
	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// The setting value.
	// +kubebuilder:validation:Optional
	Value []*string `json:"value,omitempty" tf:"value,omitempty"`
}

// SchemaSpec defines the desired state of Schema
type SchemaSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     SchemaParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider SchemaInitParameters `json:"initProvider,omitempty"`
}

// SchemaStatus defines the observed state of Schema.
type SchemaStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        SchemaObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Schema is the Schema for the Schemas API.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,confluent}
type Schema struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.format) || (has(self.initProvider) && has(self.initProvider.format))",message="spec.forProvider.format is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.subjectName) || (has(self.initProvider) && has(self.initProvider.subjectName))",message="spec.forProvider.subjectName is a required parameter"
	Spec   SchemaSpec   `json:"spec"`
	Status SchemaStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// SchemaList contains a list of Schemas
type SchemaList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Schema `json:"items"`
}

// Repository type metadata.
var (
	Schema_Kind             = "Schema"
	Schema_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Schema_Kind}.String()
	Schema_KindAPIVersion   = Schema_Kind + "." + CRDGroupVersion.String()
	Schema_GroupVersionKind = CRDGroupVersion.WithKind(Schema_Kind)
)

func init() {
	SchemeBuilder.Register(&Schema{}, &SchemaList{})
}
